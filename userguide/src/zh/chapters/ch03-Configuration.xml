<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../../target/docbook-tool-1.0/docbook-xml/docbookx.dtd">

<chapter>
  <title>配置</title>

  <section id="configuration">
    <title>创建ProcessEngine</title>

    <para>
    Activiti流程引擎的配置文件是名为<literal>activiti.cfg.xml</literal>的XML文件。
    注意这与使用<link linkend="springintegration">Spring方式创建流程引擎</link>
    是<emphasis role="bold">不</emphasis>一样的。
    </para>

    <para>
    获得<literal>ProcessEngine</literal>最简单的办法是
    使用<literal>org.activiti.engine.ProcessEngines</literal>类：
    <programlisting>ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine()</programlisting>
    它会在classpath下搜索<literal>activiti.cfg.xml</literal>，
    并基于这个文件中的配置构建引擎。
    下面代码展示了实例配置。
    后面的章节会给出配置参数的详细介绍。
    <programlisting>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

  &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;

    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000&quot; /&gt;
    &lt;property name=&quot;jdbcDriver&quot; value=&quot;org.h2.Driver&quot; /&gt;
    &lt;property name=&quot;jdbcUsername&quot; value=&quot;sa&quot; /&gt;
    &lt;property name=&quot;jdbcPassword&quot; value=&quot;&quot; /&gt;

    &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot; /&gt;

    &lt;property name=&quot;jobExecutorActivate&quot; value=&quot;false&quot; /&gt;

    &lt;property name=&quot;mailServerHost&quot; value=&quot;mail.my-corp.com&quot; /&gt;
    &lt;property name=&quot;mailServerPort&quot; value=&quot;5025&quot; /&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>
    </para>

    <para>
      注意配置XML文件其实是一个spring的配置文件。
      <emphasis role="bold">但不是说Activiti只能用在Spring环境中！</emphasis>
      我们只是利用了Spring的解析和依赖注入功能
      来构建引擎。
    </para>

    <para>
      配置文件中使用的ProcessEngineConfiguration可以通过编程方式创建。
      可以配置不同的bean id（比如，第三行）。
      <programlisting>
ProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault();
ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource);
ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName);
ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream);
ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName);</programlisting>
   也可以不使用配置文件，基于默认创建配置
   （参考<link linkend="configurationClasses">各种支持类</link>）
   <programlisting>
ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();
ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration();</programlisting>
   所有这些<literal>ProcessEngineConfiguration.createXXX()</literal>方法都返回
   <literal>ProcessEngineConfiguration</literal>，后续可以调整成所需的对象。
   在调用<literal>buildProcessEngine()</literal>后，
   就会创建一个<literal>ProcessEngine</literal>：
   <programlisting>
ProcessEngine processEngine = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration()
  .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE)
  .setJdbcUrl("jdbc:h2:mem:my-own-db;DB_CLOSE_DELAY=1000")
  .setJobExecutorActivate(true)
  .buildProcessEngine();</programlisting>
    </para>

  </section>

  <section id="configurationRoot">
    <title>ProcessEngineConfiguration bean</title>
    <para>
      <literal>activiti.cfg.xml</literal>必须包含一个id为<literal>'processEngineConfiguration'</literal>的bean。
      <programlisting> &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;</programlisting>
      这个bean会用来构建<literal>ProcessEngine</literal>。
      有多个类可以用来定义<literal>processEngineConfiguration</literal>。
      这些类对应不同的环境，并设置了对应的默认值。
      最好选择（最）适用于你的环境的类，
      这样可以少配置几个引擎的参数。
      下面是目前可以使用的类（以后会包含更多）：
      <itemizedlist id="configurationClasses">
        <listitem>
          <para>
            <emphasis role="bold">org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration</emphasis>:
            单独运行的流程引擎。Activiti会自己处理事务。
            默认，数据库只在引擎启动时检测
            （如果没有Activiti的表或者表结构不正确就会抛出异常）。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">org.activiti.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration</emphasis>:
            单元测试时的辅助类。Activiti会自己控制事务。
            默认使用H2内存数据库。数据库表会在引擎启动时创建，关闭时删除。
            使用它时，不需要其他配置（除非使用job执行器或邮件功能）。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">org.activiti.spring.SpringProcessEngineConfiguration</emphasis>:
            在Spring环境下使用流程引擎。
            参考<link linkend="springintegration">Spring集成章节</link>。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">org.activiti.engine.impl.cfg.JtaProcessEngineConfiguration</emphasis>:
            单独运行流程引擎，并使用JTA事务。
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </section>

  <section id="databaseConfiguration">
    <title>数据库配置</title>
    <para>
      Activiti可能使用两种方式配置数据库。
      第一种方式是定义数据库配置参数：
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">jdbcUrl</emphasis>: 数据库的JDBC URL。
          </para>
        </listitem>
        <listitem>
           <para>
            <emphasis role="bold">jdbcDriver</emphasis>: 对应不同数据库类型的驱动。
          </para>
        </listitem>
        <listitem>
           <para>
            <emphasis role="bold">jdbcUsername</emphasis>: 连接数据库的用户名。
          </para>
        </listitem>
        <listitem>
           <para>
            <emphasis role="bold">jdbcPassword</emphasis>: 连接数据库的密码。
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      基于JDBC参数配置的数据库连接
      会使用默认的<ulink url="http://www.mybatis.org/">MyBatis</ulink>连接池。
      下面的参数可以用来配置连接池（来自MyBatis参数）：
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">jdbcMaxActiveConnections</emphasis>:
            连接池中处于被使用状态的连接的最大值。默认为10。
          </para>
        </listitem>
        <listitem>
           <para>
            <emphasis role="bold">jdbcMaxIdleConnections</emphasis>:
            连接池中处于空闲状态的连接的最大值。
          </para>
        </listitem>
        <listitem>
           <para>
            <emphasis role="bold">jdbcMaxCheckoutTime</emphasis>:
            连接被取出使用的最长时间，超过时间会被强制回收。
            默认为20000（20秒）。
          </para>
        </listitem>
        <listitem>
           <para>
            <emphasis role="bold">jdbcMaxWaitTime</emphasis>:
            这是一个底层配置，让连接池可以在长时间无法获得连接时，
            打印一条日志，并重新尝试获取一个连接。（避免因为错误配置导致沉默的操作失败）。
            默认为20000（20秒）。
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      示例数据库配置：
      <programlisting>
&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000&quot; /&gt;
&lt;property name=&quot;jdbcDriver&quot; value=&quot;org.h2.Driver&quot; /&gt;
&lt;property name=&quot;jdbcUsername&quot; value=&quot;sa&quot; /&gt;
&lt;property name=&quot;jdbcPassword&quot; value=&quot;&quot; /&gt;
      </programlisting>
    </para>

    <para>
      也可以使用<literal>javax.sql.DataSource</literal>。
      （比如，<ulink url="http://commons.apache.org/dbcp/">Apache Commons</ulink>的DBCP）：
      <programlisting>
&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; &gt;
  &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/activiti&quot; /&gt;
  &lt;property name=&quot;username&quot; value=&quot;activiti&quot; /&gt;
  &lt;property name=&quot;password&quot; value=&quot;activiti&quot; /&gt;
  &lt;property name=&quot;defaultAutoCommit&quot; value=&quot;false&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;

    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    ...
      </programlisting>
      注意，Activiti的发布包中没有这些类。
      你要自己把对应的类（比如，从DBCP里）放到你的classpath下。
    </para>

    <para>
      无论你使用JDBC还是DataSource的方式，都可以设置下面的配置：
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">databaseType</emphasis>:
            一般不用设置，因为可以自动通过数据库连接的元数据获取。
            只有自动检测失败时才需要设置。
            可能的值有：{h2, mysql, oracle, postgres, mssql, db2}。
            <emphasis role="bold">如果没使用默认的H2数据库就必须设置这项</emphasis>。
            这个配置会决定使用哪些创建/删除脚本和查询语句。
            参考<link linkend="supporteddatabases">支持数据库章节</link>
            了解支持哪些类型。
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">databaseSchemaUpdate</emphasis>:
            设置流程引擎启动和关闭时如何处理数据库表。
            <itemizedlist>
              <listitem>
                <para>
                  <literal>false</literal>（默认）：检查数据库表的版本和依赖库的版本，
                  如果版本不匹配就抛出异常。

                </para>
              </listitem>
              <listitem>
                <para>
                  <literal>true</literal>: 构建流程引擎时，执行检查，如果需要就执行更新。
                  如果表不存在，就创建。

                </para>
              </listitem>
               <listitem>
                <para>
                  <literal>create-drop</literal>: 构建流程引擎时创建数据库表，
                  关闭流程引擎时删除这些表。
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </section>
  
  <section id="jndiDatasourceConfig">
    <title>JNDI数据库配置</title>

    <para>
		默认，Activiti的数据库配置会放在web应用的WEB-INF/classes目录下的db.properties文件中。
		这样做比较繁琐，
		因为要用户在每次发布时，都修改Activiti源码中的db.properties并重新编译war文件，
		或者解压缩war文件，修改其中的db.properties。
    </para>
    
    <para>
		使用JNDI（Java命名和目录接口）来获取数据库连接，
		连接是由servlet容器管理的，可以在war部署外边管理配置。
		与db.properties相比，
		它也允许对连接进行更多的配置。
    </para>
    
    <section id="jndi_usage">
    
        <title>使用</title>
        
        <para>
			要想把Activiti Explorer和Activiti Rest应用从db.properties转换为使用
			JNDI数据库配置，需要打开原始的Spring配置文件
			（activiti-webapp-explorer2/src/main/webapp/WEB-INF/activiti-standalone-context.xml
			和activiti-webapp-rest2/src/main/resources/activiti-context.xml），
			删除"dbProperties"和"dataSource"两个bean，然后添加如下bean：
            <programlisting>
&lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/activitiDB"/&gt;
&lt;/bean&gt;
            </programlisting> 
        </para>
        
        <para>
			接下来，我们需要添加包含了默认的H2配置的context.xml文件。
			如果已经有了JNDI配置，会覆盖这些配置。
			对Activiti Explorer来说，对应的配置文件activiti-webapp-explorer2/src/main/webapp/META-INF/context.xml
			如下所示：
            <programlisting>
&lt;Context antiJARLocking="true" path="/activiti-explorer2"&gt;
    &lt;Resource auth="Container"
              name="jdbc/activitiDB"
              type="javax.sql.DataSource"
              scope="Shareable"
              description="JDBC DataSource"
              url="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000"
              driverClassName="org.h2.Driver"
              username="sa"
              password=""
              defaultAutoCommit="false"
              initialSize="5"
              maxWait="5000"
              maxActive="120"
              maxIdle="5"/&gt;
&lt;/Context&gt;
            </programlisting>
            
            对于Activiti REST应用，添加的activiti-webapp-rest2/src/main/webapp/META-INF/context.xml
			如下所示：
            <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Context antiJARLocking="true" path="/activiti-rest2"&gt;
    &lt;Resource auth="Container"
              name="jdbc/activitiDB"
              type="javax.sql.DataSource"
              scope="Shareable"
              description="JDBC DataSource"
              url="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=-1"
              driverClassName="org.h2.Driver"
              username="sa"
              password=""
              defaultAutoCommit="false"
              initialSize="5"
              maxWait="5000"
              maxActive="120"
              maxIdle="5"/&gt;
&lt;/Context&gt;
            </programlisting>
        </para>
        
        <para>
			可选的一步，现在可以删除Activiti Explorer和Activiti Rest两个应用中
			不再使用的db.properties文件了。
        </para>
    </section>
    
    <section id="jndi_configuration">

        <title>配置</title>

        <para>
            JNDI数据库配置会因为你使用的Servlet container不同而不同。
			下面的配置可以在tomcat中使用，但是对其他容易，
			请引用你使用的容器的文档。
        </para>
        
        <para>
			如果使用tomcat，JNDI资源配置在
            $CATALINA_BASE/conf/[enginename]/[hostname]/[warname].xml
			（对于Activiti Explorer来说，通常是在$CATALINA_BASE/conf/Catalina/localhost/activiti-explorer.war）。
			当应用第一次发布时，会把这个文件从war中复制出来。
			所以如果这个文件已经存在了，你需要替换它。要想修改JNDI资源让应用连接mysql而不是H2，
			可以像下面这样修改：
            <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;Context antiJARLocking="true" path="/activiti-explorer2"&gt;
        &lt;Resource auth="Container"
            name="jdbc/activitiDB"
            type="javax.sql.DataSource"
            description="JDBC DataSource"
            url="jdbc:mysql://localhost:3306/activiti"
            driverClassName="com.mysql.jdbc.Driver"
            username="sa"
            password=""
            defaultAutoCommit="false"
            initialSize="5"
            maxWait="5000"
            maxActive="120"
            maxIdle="5"/&gt;
        &lt;/Context&gt;
           </programlisting>
       </para>

    </section>
    
  </section>

  <section id="supporteddatabases">
    <title>支持的数据库</title>
    <para>下面列出Activiti使用的数据库类型（大小写敏感）。</para>
    <table id="databaseTypes">
      <title>支持的数据库</title>
      <tgroup cols='3'>
        <thead>
          <row>
            <entry>Activiti数据库类型</entry>
            <entry>JDBC URL实例</entry>
            <entry>备注</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>h2</entry>
            <entry>jdbc:h2:tcp://localhost/activiti</entry>
            <entry>默认配置的数据库</entry>
          </row>
          <row>
            <entry>mysql</entry>
            <entry>jdbc:mysql://localhost:3306/activiti?autoReconnect=true</entry>
            <entry>使用mysql-connector-java驱动测试</entry>
          </row>
          <row>
            <entry>oracle</entry>
            <entry>jdbc:oracle:thin:@localhost:1521:xe</entry>
            <entry></entry>
          </row>
          <row>
            <entry>postgres</entry>
            <entry>jdbc:postgresql://localhost:5432/activiti</entry>
            <entry></entry>
          </row>
          <row>
            <entry>db2</entry>
            <entry>jdbc:db2://localhost:50000/activiti</entry>
            <entry></entry>
          </row>
          <row>
            <entry>mssql</entry>
            <entry>jdbc:sqlserver://localhost:1433/activiti</entry>
            <entry></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section id="creatingDatabaseTable">

    <title>创建数据库表</title>

    <para>
      下面是创建数据库表最简单的办法：
      <itemizedlist>
        <listitem>
          <para>把activiti-engine的jar放到classpath下</para>
        </listitem>
        <listitem>
          <para>添加对应的数据库驱动</para>
        </listitem>
        <listitem>
          <para>把Activiti配置文件 (<emphasis>activiti.cfg.xml</emphasis>) 放到 classpath下，
          指向你的数据库（参考<link linkend="databaseConfiguration">数据库配置章节</link>）</para>
        </listitem>
        <listitem>
          <para>执行 <emphasis>DbSchemaCreate</emphasis> 类的main方法</para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      不过，一般情况只有数据库管理员才能执行DDL语句。
	  在生产环境，这也是最明智的选择。
      SQL DDL语句可以从Activiti下载页或Activiti发布目录里找到，在<literal>database</literal>子目录下。
      脚本也包含在引擎的jar中(<emphasis>activiti-engine-x.jar</emphasis>)，
      在<emphasis>org/activiti/db/create</emphasis>包下（<emphasis>drop</emphasis>目录里是删除语句）。
      SQL文件的命名方式如下
      <programlisting>activiti.{db}.{create|drop}.{type}.sql</programlisting>
      其中 <emphasis>db</emphasis> 是 <link linkend="supporteddatabases">支持的数据库</link>，
       <emphasis>type</emphasis> 是
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">engine:</emphasis> 引擎执行的表。必须。</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">identity:</emphasis> 包含用户，群组，用户与组之间的关系的表。
          这些表是可选的，只有使用引擎自带的默认身份管理时才需要。</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">history:</emphasis> 包含历史和审计信息的表。可选的：历史级别设为<emphasis>none</emphasis>时不会使用。
          注意这也会引用一些需要把数据保存到历史表中的功能（比如任务的评论）。</para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
        <emphasis role="bold">MySQL用户需要注意：</emphasis> 版本低于5.6.4的MySQL不支持毫秒精度的timstamp或date类型。
		更严重的是，有些版本会在尝试创建这样一列时抛出异常，而有些版本则不会。
		在执行自动创建/更新时，引擎会在执行过程中修改DDL。
		当使用DDL时，可以选择通用版本和名为<emphasis>mysql55</emphasis>的文件。
		（它适合所有版本低于5.6.4的情况）。
		后一个文件会将列的类型设置为没有毫秒的情况。
    </para>

    <para>
        总结一下，对于MySQL版本会执行如下操作
        <itemizedlist>
        <listitem>
          <para><emphasis role="bold">&lt;5.6:</emphasis> 不支持毫秒精度。可以使用DDL文件（包含<emphasis>mysql55</emphasis>的文件）。可以实现自动创建/更新。</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">5.6.0 - 5.6.3:</emphasis> 不支持毫秒精度。无法自动创建/更新。建议更新到新的数据库版本。如果真的需要的话，也可以使用<emphasis>mysql 5.5</emphasis>。</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">5.6.4+:</emphasis>支持毫秒精度。可以使用DDL文件（默认包含<emphasis>mysql</emphasis>的文件）。可以实现自动创建、更新。</para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
		注意对于已经更新了MySQL数据库，而且Activiti表已经创建/更新的情况，
		必须手工修改列的类型。
    </para>

  </section>

  <section id="database.tables.explained">
    <title>理解数据库表的命名</title>
    <para>
      Activiti的表都以<emphasis role="bold">ACT_</emphasis>开头。
      第二部分是表示表的用途的两个字母标识。
      用途也和服务的API对应。
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">ACT_RE_*</emphasis>: 'RE'表示<literal>repository</literal>。
            这个前缀的表包含了流程定义和流程静态资源
            （图片，规则，等等）。
          </para>
        </listitem>
         <listitem>
          <para>
            <emphasis role="bold">ACT_RU_*</emphasis>: 'RU'表示<literal>runtime</literal>。
            这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。
            Activiti只在流程实例执行过程中保存这些数据，
            在流程结束时就会删除这些记录。
            这样运行时表可以一直很小速度很快。
          </para>
        </listitem>
         <listitem>
          <para>
            <emphasis role="bold">ACT_ID_*</emphasis>: 'ID'表示<literal>identity</literal>。
            这些表包含身份信息，比如用户，组等等。
          </para>
        </listitem>
         <listitem>
          <para>
            <emphasis role="bold">ACT_HI_*</emphasis>: 'HI'表示<literal>history</literal>。
            这些表包含历史数据，比如历史流程实例，
            变量，任务等等。
          </para>
        </listitem>
         <listitem>
          <para>
            <emphasis role="bold">ACT_GE_*</emphasis>: <literal>通用</literal>数据，
            用于不同场景下。
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </section>

  <section id="databaseUpgrade">
     <title>数据库升级</title>
     <para>在执行更新之前要先备份数据库
     （使用数据库的备份功能）
     </para>
     <para>默认，每次构建流程引擎时都会进行版本检测。
     这一切都在应用启动或Activiti webapp启动时发生。
     如果Activiti发现数据库表的版本与依赖库的版本不同，
     就会抛出异常。
     </para>
     <para>要升级，你要把下面的配置
     放到activiti.cfg.xml配置文件里：
     </para>
    <programlisting>&lt;beans ... &gt;

  &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;
    &lt;!-- ... --&gt;
    &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot; /&gt;
    &lt;!-- ... --&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>
     <para> <emphasis role="bold">然后，把对应的数据库驱动放到classpath里。</emphasis>
     升级应用的Activiti依赖。启动一个新版本的Activiti
     指向包含旧版本的数据库。将<literal>databaseSchemaUpdate</literal>设置为<literal>true</literal>，
     Activiti会自动将数据库表升级到新版本，
     当发现依赖和数据库表版本不通过时。
     </para>
     <para> <emphasis role="bold">也可以执行更新升级DDL语句。</emphasis>
     也可以执行数据库脚本，可以在Activiti下载页找到。
     </para>
   </section>

  <section id="jobExecutorConfiguration">
    <title>启用Job执行器</title>
    <para><literal>JobExecutor</literal>是管理一系列线程的组件，可以触发定时器（也包含后续的异步消息）。
    在单元测试场景下，很难使用多线程。因此API允许查询(<literal>ManagementService.createJobQuery</literal>)和执行job
    (<literal>ManagementService.executeJob</literal>)，所以job可以在单元测试中控制。
    要避免与job执行器冲突，可以关闭它。
    </para>
    <para>
    默认，<literal>JobExecutor</literal>在流程引擎启动时就会激活。
    如果不想在流程引擎启动后自动激活<literal>JobExecutor</literal>，可以设置
   <programlisting>&lt;property name=&quot;jobExecutorActivate&quot; value=&quot;false&quot; /></programlisting>
    </para>
  </section>

  <section id="mailServerConfiguration">
    <title>配置邮件服务器</title>
    <para>
      可以选择配置邮件服务器。Activiti支持在业务流程中发送邮件。
      想真正的发送一个email，必须配置一个真实的SMTP邮件服务器。
      参考<link linkend="bpmnEmailTaskServerConfiguration">e-mail任务</link>。
    </para>
  </section>

  <section id="historyConfiguration">
    <title>配置历史</title>
    <para>
      可以选择定制历史存储的配置。你可以通过配置影响引擎的<link linkend="history">历史功能</link>。
      参考<link linkend="historyConfig">历史配置</link>。
      <programlisting>&lt;property name=&quot;history&quot; value=&quot;audit&quot; /&gt;</programlisting>
    </para>
  </section>

  <section id="exposingConfigurationBeans">
    <title>为表达式和脚本暴露配置</title>
    <para>默认，<literal>activiti.cfg.xml</literal>和你自己的Spring配置文件中所有bean
    都可以在表达式和脚本中使用。
    如果你想限制配置文件中的bean的可见性，
    可以配置流程引擎配置的beans配置。
    <literal>ProcessEngineConfiguration</literal>的beans是一个map。当你指定了这个参数，
    只有包含这个map中的bean可以在表达式和脚本中使用。
    通过在map中指定的名称来决定暴露的bean。
    </para>
  </section>
  <section id="processDefinitionCacheConfiguration">
    <title>配置部署缓存</title>
    <para>所有流程定义都被缓存了（解析之后）避免每次使用前都要访问数据库，
    因为流程定义数据是不会改变的。
    默认，不会限制这个缓存。如果想限制流程定义缓存，可以添加如下配置
    <programlisting>&lt;property name=&quot;processDefinitionCacheLimit&quot; value=&quot;10&quot; /&gt;</programlisting>
    这个配置会把默认的hashmap缓存替换成LRU缓存，来提供限制。
    当然，这个配置的最佳值跟流程定义的总数有关，
    实际使用中会具体使用多少流程定义也有关。</para>
    <para>也你可以注入自己的缓存实现。这个bean必须实现
    org.activiti.engine.impl.persistence.deploy.DeploymentCache接口：
    <programlisting>
&lt;property name=&quot;processDefinitionCache&quot;&gt;
  &lt;bean class=&quot;org.activiti.MyCache&quot; />
&lt;/property&gt;</programlisting></para>
     <para>有一个类似的配置叫<literal>knowledgeBaseCacheLimit</literal>和<literal>knowledgeBaseCache</literal>，
     它们是配置规则缓存的。只有流程中使用规则任务时才会用到。</para>
    </section>

  <section id="loggingConfiguration">
    <title>日志</title>
    <para>从Activiti 5.12开始，SLF4J被用作日志框架，替换了之前使用java.util.logging。
    所有日志（activiti, spring, mybatis等等）都转发给SLF4J
    允许使用你选择的日志实现。</para>
    <para><emphasis role="bold">默认activiti-engine依赖中没有提供SLF4J绑定的jar，
    需要根据你的实际需要使用日志框架。</emphasis>如果没有添加任何实现jar，SLF4J会使用NOP-logger，不使用任何日志，不会发出警告，而且什么日志都不会记录。
    可以通过<ulink url="http://www.slf4j.org/codes.html#StaticLoggerBinder">http://www.slf4j.org/codes.html#StaticLoggerBinder</ulink>了解这些实现。</para>

    <para>使用Maven，比如使用一个依赖（这里使用log4j），注意你还需要添加一个version：
    <programlisting>
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting></para>

    <para>activiti-explorer和activiti-rest应用都使用了Log4j绑定。执行所有activiti-*模块的单元测试页使用了Log4j。</para>

    <para>
      <emphasis role="bold">特别提醒如果容器classpath中存在commons-logging：</emphasis>
	  为了把spring日志转发给SLF4J，需要使用桥接（参考<ulink url="http://www.slf4j.org/legacy.html#jclOverSLF4J">http://www.slf4j.org/legacy.html#jclOverSLF4J</ulink>）。
	  如果你的容器提供了commons-logging实现，请参考下面网页：<ulink url="http://www.slf4j.org/codes.html#release">http://www.slf4j.org/codes.html#release</ulink>来确保稳定性。
    </para>
    <para>
	  使用Maven的实例（忽略版本）：
      <programlisting>
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
    </para>
  </section>

    <section id="MDC">

  <title>映射诊断上下文</title>

    <para>
		在5.13中，activiti支持slf4j的MDC功能。
		如下的基础信息会传递到日志中记录：
      <itemizedlist>
        <listitem>
            <para>
            流程定义Id标记为mdcProcessDefinitionID
            </para>
        </listitem>

        <listitem>
        <para>
            流程实例Id标记为mdcProcessInstanceID
            </para>
        </listitem>

        <listitem>
        <para>
            分支Id标记为mdcexecutionId
        </para>
        </listitem>
      </itemizedlist>


	  默认不会记录这些信息。可以配置日志使用期望的格式来显示它们，扩展通常的日志信息。
	  比如，下面的log4j配置定义会让日志显示上面提及的信息：
     <programlisting>
 log4j.appender.consoleAppender.layout.ConversionPattern =ProcessDefinitionId=%X{mdcProcessDefinitionID}
executionId=%X{mdcExecutionId} mdcProcessInstanceID=%X{mdcProcessInstanceID} mdcBusinessKey=%X{mdcBusinessKey} %m%n"
      </programlisting>
	  当系统进行高风险任务，日志必须严格检查时，这个功能就非常有用，比如要使用日志分析的情况。

    </para>
  </section>


  <section id="eventDispatcher">
    <title>事件处理</title>
    <para>
      Activiti 5.15中实现了一种事件机制。它允许在引擎触发事件时获得提醒。
	  参考<link linkend="eventDispatcherEventTypes">所有支持的事件类型</link>了解有效的事件。
    </para>
    <para>
      可以为对应的事件类型注册监听器，在这个类型的任何时间触发时都会收到提醒。
	  你可以添加引擎范围的事件监听器<link linkend="eventDispatcherConfiguration">通过配置</link>，
	  添加引擎范围的事件监听器<link linkend="eventDispatcherConfigurationRuntime">在运行阶段使用API</link>，
	  或添加event-listener到<link linkend="eventDispatcherConfigurationProcessDefinition">特定流程定义的BPMN XML中</link>。
    </para>
    <para>
       所有分发的事件，都是<literal>org.activiti.engine.delegate.event.ActivitiEvent</literal>的子类。事件包含（如果有效）<literal>type</literal>，<literal>executionId</literal>，<literal>processInstanceId</literal>和<literal>processDefinitionId</literal>。
	   对应的事件会包含事件发生时对应上下文的额外信息，
	   这些额外的载荷可以在<link linkend="eventDispatcherEventTypes">支持的所有事件类型</link>中找到。
    </para>

      <section id="eventDispatcherListener">
        <title>事件监听器实现</title>
        <para>
          实现事件监听器的唯一要求是实现<literal>org.activiti.engine.delegate.event.ActivitiEventListener</literal>。
		  西面是一个实现监听器的例子，它会把所有监听到的事件打印到标准输出中，包括job执行的事件异常：
          <programlisting>
public class MyEventListener implements ActivitiEventListener {

  @Override
  public void onEvent(ActivitiEvent event) {
    switch (event.getType()) {

      case JOB_EXECUTION_SUCCESS:
        System.out.println("A job well done!");
        break;

      case JOB_EXECUTION_FAILURE:
        System.out.println("A job has failed...");
        break;

      default:
        System.out.println("Event received: " + event.getType());
    }
  }

  @Override
  public boolean isFailOnException() {
    // The logic in the onEvent method of this listener is not critical, exceptions
    // can be ignored if logging fails...
    return false;
  }
}</programlisting>
        </para>
        <para>
		  <literal>isFailOnException()</literal>方法决定了当事件分发时，<literal>onEvent(..)</literal>方法抛出异常时的行为。
		  这里返回的是<literal>false</literal>，会忽略异常。
		  当返回<literal>true</literal>时，异常不会忽略，继续向上传播，迅速导致当前命令失败。
		  当事件是一个API调用的一部分时（或其他事务性操作，比如job执行），
		  事务就会回滚。当事件监听器中的行为不是业务性时，建议返回<literal>false</literal>。
        </para>
        <para>
           activiti提供了一些基础的实现，实现了事件监听器的常用场景。可以用来作为基类或监听器实现的样例：
           <itemizedlist>
              <listitem>
                <para>
                  <emphasis role="bold">org.activiti.engine.delegate.event.BaseEntityEventListener</emphasis>：
				  这个事件监听器的基类可以用来监听实体相关的事件，可以针对某一类型实体，也可以是全部实体。
				  它隐藏了类型检测，并提供了三个需要重写的方法：<literal>onCreate(..)</literal>, <literal>onUpdate(..)</literal> 和 <literal>onDelete(..)</literal>，当实体创建，更新，或删除时调用。对于其他实体相关的事件，会调用
				  <literal>onEntityEvent(..)</literal>。
                </para>
              </listitem>
           </itemizedlist>
        </para>
      </section>
    <section id="eventDispatcherConfiguration">
        <title>配置与安装</title>
        <para>
          把事件监听器配置到流程引擎配置中时，会在流程引擎启动时激活，并在引擎启动启动中持续工作着。
        </para>
        <para>
		  <literal>eventListeners</literal>属性需要<literal>org.activiti.engine.delegate.event.ActivitiEventListener</literal>的队列。
		  通常，我们可以声明一个内部的bean定义，或使用<literal>ref</literal>引用已定义的bean。
		  下面的代码，向配置添加了一个事件监听器，任何事件触发时都会提醒它，无论事件是什么类型：
                <programlisting>
&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;
    ...
    &lt;property name=&quot;eventListeners&quot;&gt;
      &lt;list&gt;
         &lt;bean class=&quot;org.activiti.engine.example.MyEventListener&quot; /&gt;
      &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
        </para>
        <para>
		  为了监听特定类型的事件，可以使用<literal>typedEventListeners</literal>属性，它需要一个map参数。
		  map的key是逗号分隔的事件名（或单独的事件名）。
		  map的value是<literal>org.activiti.engine.delegate.event.ActivitiEventListener</literal>队列。
		  下面的代码演示了向配置中添加一个事件监听器，可以监听job执行成功或失败：
                <programlisting>
&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;
    ...
    &lt;property name=&quot;typedEventListeners&quot;&gt;
      &lt;map&gt;
        &lt;entry key=&quot;JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE&quot; &gt;
          &lt;list&gt;
            &lt;bean class=&quot;org.activiti.engine.example.MyJobEventListener&quot; /&gt;
          &lt;/list&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
        </para>
        <para>分发事件的顺序是由监听器添加时的顺序决定的。首先，会调用所有普通的事件监听器（<literal>eventListeners</literal>属性），按照它们在<literal>list</literal>中的次序。
		然后，会调用所有对应类型的监听器（<literal>typedEventListeners</literal>属性），如果对应类型的事件被触发了。</para>
      </section>
      <section id="eventDispatcherConfigurationRuntime">
        <title>在运行阶段添加监听器</title>
        <para>可以通过API（<literal>RuntimeService</literal>）在运行阶段添加或删除额外的事件监听器：
        <programlisting>
/**
 * Adds an event-listener which will be notified of ALL events by the dispatcher.
 * @param listenerToAdd the listener to add
 */
void addEventListener(ActivitiEventListener listenerToAdd);

/**
 * Adds an event-listener which will only be notified when an event occurs, which type is in the given types.
 * @param listenerToAdd the listener to add
 * @param types types of events the listener should be notified for
 */
void addEventListener(ActivitiEventListener listenerToAdd, ActivitiEventType... types);

/**
 * Removes the given listener from this dispatcher. The listener will no longer be notified,
 * regardless of the type(s) it was registered for in the first place.
 * @param listenerToRemove listener to remove
 */
 void removeEventListener(ActivitiEventListener listenerToRemove);</programlisting>
        </para>
        <para>
          注意运行期添加的监听器<emphasis role="bold">引擎重启后就消失了。</emphasis>
        </para>
      </section>
      <section id="eventDispatcherConfigurationProcessDefinition">
        <title>为流程定义添加监听器</title>
        <para>可以为特定流程定义添加监听器。监听器只会监听与这个流程定义相关的事件，以及这个流程定义上发起的所有流程实例的事件。
		监听器实现可以使用，全类名定义，引用实现了监听器接口的表达式，或配置为抛出一个message/signal/error的BPMN事件。
        </para>
        <section>
        <title>让监听器执行用户定义的逻辑</title>
        <para>下面代码为一个流程定义添加了两个监听器。第一个监听器会接收所有类型的事件，它是通过全类名定义的。
		第二个监听器只接收作业成功或失败的事件，它使用了定义在流程引擎配置中的<literal>beans</literal>属性中的一个bean。</para>
        <programlisting>
&lt;process id="testEventListeners"&gt;
  &lt;extensionElements&gt;
    &lt;activiti:eventListener class=&quot;org.activiti.engine.test.MyEventListener&quot; /&gt;
    &lt;activiti:eventListener delegateExpression=&quot;${testEventListener}&quot; events=&quot;JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE&quot; /&gt;
  &lt;/extensionElements&gt;

  ...

&lt;/process&gt;</programlisting>
      <para>对于实体相关的事件，也可以设置为针对某个流程定义的监听器，实现只监听发生在某个流程定义上的某个类型实体事件。
	  下面的代码演示了如何实现这种功能。可以用于所有实体事件（第一个例子），也可以只监听特定类型的事件（第二个例子）。</para>
        <programlisting>
&lt;process id="testEventListeners"&gt;
  &lt;extensionElements&gt;
    &lt;activiti:eventListener class=&quot;org.activiti.engine.test.MyEventListener&quot; entityType=&quot;task&quot; /&gt;
    &lt;activiti:eventListener delegateExpression=&quot;${testEventListener}&quot; events=&quot;ENTITY_CREATED&quot; entityType=&quot;task&quot; /&gt;
  &lt;/extensionElements&gt;

  ...

&lt;/process&gt;</programlisting>
<para><literal>entityType</literal>支持的值有：<literal>attachment</literal>, <literal>comment</literal>, <literal>execution</literal>,<literal>identity-link</literal>, <literal>job</literal>, <literal>process-instance</literal>,
<literal>process-definition</literal>, <literal>task</literal>。</para>
</section>
<section>
        <title>监听抛出BPMN事件</title>
        <para>
          <link linkend="experimental">
            <emphasis role="bold">[试验阶段]</emphasis>
          </link>
        </para>
        <para>另一种处理事件的方法是抛出一个BPMN事件。请注意它只针对与抛出一个activiti事件类型的BPMN事件。
		比如，抛出一个BPMN事件，在流程实例删除时，会导致一个错误。
		下面的代码演示了如何在流程实例中抛出一个signal，把signal抛出到外部流程（全局），在流程实例中抛出一个消息事件，
		在流程实例中抛出一个错误事件。除了使用<literal>class</literal>或<literal>delegateExpression</literal>，
		还使用了<literal>throwEvent</literal>属性，通过额外属性，指定了抛出事件的类型。</para>
        <programlisting>
&lt;process id="testEventListeners"&gt;
  &lt;extensionElements&gt;
    &lt;activiti:eventListener throwEvent=&quot;signal&quot; signalName=&quot;My signal&quot; events=&quot;TASK_ASSIGNED&quot; /&gt;
  &lt;/extensionElements&gt;
&lt;/process&gt;</programlisting>
        <programlisting>
&lt;process id="testEventListeners"&gt;
  &lt;extensionElements&gt;
    &lt;activiti:eventListener throwEvent=&quot;globalSignal&quot; signalName=&quot;My signal&quot; events=&quot;TASK_ASSIGNED&quot; /&gt;
  &lt;/extensionElements&gt;
&lt;/process&gt;</programlisting>
        <programlisting>
&lt;process id="testEventListeners"&gt;
  &lt;extensionElements&gt;
    &lt;activiti:eventListener throwEvent=&quot;message&quot; messageName=&quot;My message&quot; events=&quot;TASK_ASSIGNED&quot; /&gt;
  &lt;/extensionElements&gt;
&lt;/process&gt;</programlisting>
        <programlisting>
&lt;process id="testEventListeners"&gt;
  &lt;extensionElements&gt;
    &lt;activiti:eventListener throwEvent=&quot;error&quot; errorCode=&quot;123&quot; events=&quot;TASK_ASSIGNED&quot; /&gt;
  &lt;/extensionElements&gt;
&lt;/process&gt;</programlisting>

<para>如果需要声明额外的逻辑，是否抛出BPMN事件，可以扩展activiti提供的监听器类。在子类中重写<literal>isValidEvent(ActivitiEvent event)</literal>，
可以防止抛出BPMN事件。对应的类是<literal>org.activiti.engine.test.api.event.SignalThrowingEventListenerTest</literal>, <literal>org.activiti.engine.impl.bpmn.helper.MessageThrowingEventListener</literal> 和 <literal>org.activiti.engine.impl.bpmn.helper.ErrorThrowingEventListener</literal>.</para>

      </section>
       <section>
        <title>流程定义中监听器的注意事项</title>
      <para>
        <itemizedlist>
          <listitem>
            <para>
              事件监听器只能声明在<literal>process</literal>元素中，作为<literal>extensionElements</literal>的子元素。
			  监听器不能定义在流程的单个activity下。
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>delegateExpression</literal>中的表达式无法访问execution上下文，这与其他表达式不同（比如gateway）。
			  它只能引用定义在流程引擎配置的<literal>beans</literal>属性中声明的bean，或者使用spring（未使用beans属性）中所有实现了监听器接口的spring-bean。
            </para>
          </listitem>
          <listitem>
            <para>
              在使用监听器的 <literal>class</literal> 属性时，只会创建一个实例。记住监听器实现不会依赖成员变量，
			  确认是多线程安全的。
            </para>
          </listitem>
          <listitem>
            <para>
              当一个非法的事件类型用在<literal>events</literal>属性或<literal>throwEvent</literal>中时，流程定义发布时就会抛出异常。（会导致部署失败）。如果<literal>class</literal>或<literal>delegateExecution</literal>由问题（类不存在，不存在的bean引用，或代理类没有实现监听器接口），会在流程启动时抛出异常（或在第一个有效的流程定义事件被监听器接收时）。所以要保证引用的类正确的放在classpath下，表达式也要引用一个有效的实例。
            </para>
          </listitem>
        </itemizedlist>
      </para>
</section>
      </section>
      <section id="eventDispatcherCustomEvents">
        <title>通过API分发事件</title>
        <para>我们提供了通过API使用事件机制的方法，允许大家触发定义在引擎中的任何自定义事件。
		建议（不强制）只触发类型为<literal>CUSTOM</literal>的<literal>ActivitiEvents</literal>。可以通过<literal>RuntimeService</literal>触发事件：
        <programlisting>
/**
 * Dispatches the given event to any listeners that are registered.
 * @param event event to dispatch.
 *
 * @throws ActivitiException if an exception occurs when dispatching the event or when the {@link ActivitiEventDispatcher}
 * is disabled.
 * @throws ActivitiIllegalArgumentException when the given event is not suitable for dispatching.
 */
 void dispatchEvent(ActivitiEvent event);</programlisting>
        </para>
      </section>

       <section id="eventDispatcherEventTypes">
        <title>支持的事件类型</title>
        <para>下面是引擎中可能出现的所有事件类型。每个类型都对应<literal>org.activiti.engine.delegate.event.ActivitiEventType</literal>中的一个枚举值。</para>

        <table id="eventTypes">
          <title>支持的事件</title>
          <tgroup cols='3'>
            <thead>
              <row>
                <entry>事件名称</entry>
                <entry>描述</entry>
                <entry>事件类型</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>ENGINE_CREATED</entry>
                <entry>监听器监听的流程引擎已经创建完毕，并准备好接受API调用。</entry>
                <entry><literal>org.activiti...ActivitiEvent</literal></entry>
              </row>
              <row>
                <entry>ENGINE_CLOSED</entry>
                <entry>监听器监听的流程引擎已经关闭，不再接受API调用。</entry>
                <entry><literal>org.activiti...ActivitiEvent</literal></entry>
              </row>
              <row>
                <entry>ENTITY_CREATED</entry>
                <entry>创建了一个新实体。实体包含在事件中。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>ENTITY_INITIALIZED</entry>
                <entry>创建了一个新实体，初始化也完成了。如果这个实体的创建会包含子实体的创建，这个事件会在子实体都创建/初始化完成后被触发，这是与<literal>ENTITY_CREATED</literal>的区别。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>ENTITY_UPDATED</entry>
                <entry>更新了已存在的实体。实体包含在事件中。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>ENTITY_DELETED</entry>
                <entry>删除了已存在的实体。实体包含在事件中。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>ENTITY_SUSPENDED</entry>
                <entry>暂停了已存在的实体。实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>ENTITY_ACTIVATED</entry>
                <entry>激活了已存在的实体，实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>JOB_EXECUTION_SUCCESS</entry>
                <entry>作业执行成功。job包含在事件中。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>JOB_EXECUTION_FAILURE</entry>
                <entry>作业执行失败。作业和异常信息包含在事件中。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal> and <literal>org.activiti...ActivitiExceptionEvent</literal></entry>
              </row>
              <row>
                <entry>JOB_RETRIES_DECREMENTED</entry>
                <entry>因为作业执行失败，导致重试次数减少。作业包含在事件中。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>TIMER_FIRED</entry>
                <entry>触发了定时器。job包含在事件中。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>JOB_CANCELED</entry>
                <entry>取消了一个作业。事件包含取消的作业。作业可以通过API调用取消，
				  任务完成后对应的边界定时器也会取消，在新流程定义发布时也会取消。
                </entry>
                <entry>
                  <literal>org.activiti...ActivitiEntityEvent</literal>
                </entry>
              </row>
              <row>
                <entry>ACTIVITY_STARTED</entry>
                <entry>一个节点开始执行</entry>
                <entry><literal>org.activiti...ActivitiActivityEvent</literal></entry>
              </row>
              <row>
                <entry>ACTIVITY_COMPLETED</entry>
                <entry>一个节点成功结束</entry>
                <entry><literal>org.activiti...ActivitiActivityEvent</literal></entry>
              </row>
              <row>
                <entry>ACTIVITY_SIGNALED</entry>
                <entry>一个节点收到了一个信号</entry>
                <entry><literal>org.activiti...ActivitiSignalEvent</literal></entry>
              </row>
              <row>
                <entry>ACTIVITY_MESSAGE_RECEIVED</entry>
                <entry>一个节点收到了一个消息。在节点收到消息之前触发。收到后，会触发<literal>ACTIVITY_SIGNAL</literal>或<literal>ACTIVITY_STARTED</literal>，这会根据节点的类型（边界事件，事件子流程开始事件）</entry>
                <entry><literal>org.activiti...ActivitiMessageEvent</literal></entry>
              </row>
              <row>
                <entry>ACTIVITY_ERROR_RECEIVED</entry>
                <entry>一个节点收到了一个错误事件。在节点实际处理错误之前触发。
				事件的<literal>activityId</literal>对应着处理错误的节点。
				这个事件后续会是<literal>ACTIVITY_SIGNALLED</literal>或<literal>ACTIVITY_COMPLETE</literal>，
				如果错误发送成功的话。</entry>
                <entry><literal>org.activiti...ActivitiErrorEvent</literal></entry>
              </row>
              <row>
                <entry>UNCAUGHT_BPMN_ERROR</entry>
                <entry>抛出了未捕获的BPMN错误。流程没有提供针对这个错误的处理器。
				事件的<literal>activityId</literal>为空。</entry>
                <entry><literal>org.activiti...ActivitiErrorEvent</literal></entry>
              </row>
              <row>
                <entry>ACTIVITY_COMPENSATE</entry>
                <entry>一个节点将要被补偿。事件包含了将要执行补偿的节点id。</entry>
                <entry><literal>org.activiti...ActivitiActivityEvent</literal></entry>
              </row>
              <row>
                <entry>VARIABLE_CREATED</entry>
                <entry>创建了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。</entry>
                <entry><literal>org.activiti...ActivitiVariableEvent</literal></entry>
              </row>
              <row>
                <entry>VARIABLE_UPDATED</entry>
                <entry>更新了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。</entry>
                <entry><literal>org.activiti...ActivitiVariableEvent</literal></entry>
              </row>
              <row>
                <entry>VARIABLE_DELETED</entry>
                <entry>删除了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。</entry>
                <entry><literal>org.activiti...ActivitiVariableEvent</literal></entry>
              </row>
              <row>
                <entry>TASK_ASSIGNED</entry>
                <entry>任务被分配给了一个人员。事件包含任务。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>TASK_CREATED</entry>
                <entry>创建了新任务。它位于<literal>ENTITY_CREATE</literal>事件之后。当任务是由流程创建时，
				  这个事件会在TaskListener执行之前被执行。
                </entry>
                <entry>
                  <literal>org.activiti...ActivitiEntityEvent</literal>
                </entry>
              </row>
              <row>
                <entry>TASK_COMPLETED</entry>
                <entry>任务被完成了。它会在<literal>ENTITY_DELETE</literal>事件之前触发。当任务是流程一部分时，事件会在流程继续运行之前，
				后续事件将是<literal>ACTIVITY_COMPLETE</literal>，对应着完成任务的节点。</entry>
                <entry><literal>org.activiti...ActivitiEntityEvent</literal></entry>
              </row>
              <row>
                <entry>TASK_TIMEOUT</entry>
                <entry>任务已超时，在<literal>TIMER_FIRED</literal>事件之后，会触发用户任务的超时事件，
				  当这个任务分配了一个定时器的时候。
                </entry>
                <entry>
                  <literal>org.activiti...ActivitiEntityEvent</literal>
                </entry>
              </row>
              <row>
                <entry>PROCESS_COMPLETED</entry>
                <entry>流程已结束。在最后一个节点的<literal>ACTIVITY_COMPLETED</literal>事件之后触发。
				  当流程到达的状态，没有任何后续连线时，
				  流程就会结束。
                </entry>
                <entry>
                  <literal>org.activiti...ActivitiEntityEvent</literal>
                </entry>
              </row>
              <row>
                <entry>MEMBERSHIP_CREATED</entry>
                <entry>用户被添加到一个组里。事件包含了用户和组的id。</entry>
                <entry><literal>org.activiti...ActivitiMembershipEvent</literal></entry>
              </row>
              <row>
                <entry>MEMBERSHIP_DELETED</entry>
                <entry>用户被从一个组中删除。事件包含了用户和组的id。</entry>
                <entry><literal>org.activiti...ActivitiMembershipEvent</literal></entry>
              </row>
              <row>
                <entry>MEMBERSHIPS_DELETED</entry>
                <entry>所有成员被从一个组中删除。在成员删除之前触发这个事件，所以他们都是可以访问的。
				因为性能方面的考虑，不会为每个成员触发单独的<literal>MEMBERSHIP_DELETED</literal>事件。</entry>
                <entry><literal>org.activiti...ActivitiMembershipEvent</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>
		  引擎内部所有<literal>ENTITY_*</literal>事件都是与实体相关的。下面的列表展示了实体事件与实体的对应关系：

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold"><literal>ENTITY_CREATED, ENTITY_INITIALIZED, ENTITY_DELETED</literal></emphasis>: Attachment, Comment, Deployment, Execution, Group, IdentityLink, Job, Model, ProcessDefinition, ProcessInstance, Task, User.</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold"><literal>ENTITY_UPDATED</literal></emphasis>: Attachment, Deployment, Execution, Group, IdentityLink, Job, Model, ProcessDefinition, ProcessInstance, Task, User.</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold"><literal>ENTITY_SUSPENDED, ENTITY_ACTIVATED</literal></emphasis>: ProcessDefinition, ProcessInstance/Execution, Task.</para>
            </listitem>
          </itemizedlist>
        </para>
    </section>

      <section id="eventDispatcherRemarks">
        <title>附加信息</title>
        <para>
		  <emphasis role="bold">只有同一个流程引擎中的事件会发送给对应的监听器。</emphasis>。的那个你有很多引擎 - 在同一个数据库运行 -
		  事件只会发送给注册到对应引擎的监听器。其他引擎发生的事件不会发送给这个监听器，无论实际上它们运行在同一个或不同的JVM中。
        </para>
        <para>
          对应的事件类型（对应实体）都包含对应的实体。根据类型或事件，这些实体不能再进行更新（比如，当实例以被删除）。可能的话，使用事件提供的<literal>EngineServices</literal>来以安全的方式来操作引擎。即使如此，你需要小心的对事件对应的实体进行更新/操作。
        </para>
        <para>
          没有对应历史的实体事件，因为它们都有运行阶段的对应实体。
        </para>
      </section>
  </section>

</chapter>
